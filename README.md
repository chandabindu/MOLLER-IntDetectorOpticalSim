#Instructions for running the MakeScanMacros.py and submit.py/sh scripts

MOLLEROpt generates a root file after being fed a macro filled with geometry parameters for the main detector

#TO BUILD

Do mkdir build, cd build, cmake .., and then make -j16 (-j# signifies the # of cores you wish to use)

#TO RUN INDIVIDUAL MACROS

In the build directory, do ./MOLLEROpt, then in the GUI type /control/execute macros/"macro-name". You can also do ./MOLLEROpt "path/macro-name" from the terminal

#TO SUBMIT MULTIPLE MACROS VIA SLURM

This method is for submitting multiple jobs to a computer cluster. It is based on slurm and works on the ifarm

To generate multiple macros, do python2.7 MakeScanMacros3.py within the build folder. The generated macros will be stored in RingParamScan, and a .dat file "files.dat" will be generated that lists each macro generated as a string

Once the macros are generated, do ./submit.sh. This will submit the macros as jobs to the cluster. The generated root files will be moved to the rootfiles directory upon completion. .rndm files are currently moved by hand

When the root files are complete, you can analyze and plot the data via ExtractScanResults by doing root, .L ExtractScanResults.C and then ExtractScanResults()

ExtractScanResults.C performs a langau fit for each root file. The parameters can be modifed depending on what's needed

#MACROS & SCRIPTS

myRun.mac: Runs a single job on the local device; To run do ./MOLLEROpt "macros/myRun.mac". The GUI is not required

vis.mac: Visualizes the geometry described in vis.mac. To run do ./MOLLEROpt to open the GUI, and from there do /control/execute macros/vis.mac

MakeScanMacros3.py: Generates a list of macro files that are similar in form to myRun.mac

submit.py: Parses through macros generated by MakeScanMacros3.py and submits them to the ifarm. It is called by doing ./submit.sh

submit.sh: Calls submit.py

ExtractScanResults.C: Reads files.dat and outputs plots of the PE yield with a langau fit. The plots need to be manually saved and closed, but that can be changed

#IMPORTANT NOTES

The geometry generated has a box between the upper and lower cones of the detector. Its height (controllable in the macros) can be anything greater than 0.0

When running MakeScanMacros3.py and submit.py you have to add the output directories for the generated files. The lines to edit are below:
* MakeScanMacros3.py: text_root += "file-path/build/root_files/root-file"
* submit.py: outDir = "file-path/build/root_files/"

The following versions of ROOT and G4 are used:
* ROOT 6.22/08 with all required and recommended support programs
* Geant4 10.06
* The simulation uses a modified G4OpBoundaryProcess class, to allow evaluation of angle dependent reflectivity
* The corresponding modified class files are in the 'data' subdirectory and need to be copied to 'G4SourceDir/source/processes/optical/'  
* and G4 needs to recompiled.


# READOUT

The simulation data is saved in a root file that can be given a unique ID from the macro '/RunAction/SetID'. The root file contains a tree that is not electron event based, but rather based on Cherenkov photon events. So the number of track entries in the tree is much larger than than number of electron events. Various things are recorded, including:

  * 'PMTPhotonEnergy'
  * 'PMTCathodeHitX'
  * 'PMTCathodeHitY'
  * 'PMTWindowReflectionAngle'
  
  * 'LightGuideTrackHit'
  * 'LightGuidePhotonEnergy'
  * 'LightGuideSteps'
  * 'LightGuideStepLength'
  * 'LightGuideTrackLength'
  * 'LightGuideIncidentPhotonAngle'
  * 'LightGuideReflectionProcess'

  * 'QuartzTrackHit'
  * 'QuartzHitX'
  * 'QuartzHitY'

  * 'QuartzPhotonEnergy'
  * 'QuartzSecondaryPhotonAngle'
  * 'QuartzSteps'
  * 'QuartzStepLength'
  * 'QuartzElectronStepLength'
  * 'QuartzIncidentPhotonAngle'
  * 'QuartzTrackLength'
  * 'QuartzStepNPhotons'
  * 'QuartzPhotonAtExit'

  * 'TotalSteps'
  * 'TotalTrackLength'

One can then, for example, plot:

  * 'tv__tree->Draw("MOLLERDetectorEvent.QuartzTrackLength:MOLLERDetectorEvent.QuartzSteps>>hist5(700,0,700,1600,0,1600)","MOLLERDetectorEvent.LightGuideTrackHit == 1","colz");'

etc.

#DATA

The data folder contains optical properties of multiple materials (reflectivity, refractive index, permitivity, absorption, etc). This data is then organized into a table called OpticalPropertiesInputData.txt

When updating the material properties, you make changes to GenerateOpticalTable.C, do .L GenerateOpticalTable.C, and the run the objects within as needed. For example,  when changing the reflectivity of the light guide, you would run FillGuideReflectivity()

After running the objects the table can be updated by doing MakeTable(). Now when you do "make" in the build directory the updated optical table will be placed in build/data
